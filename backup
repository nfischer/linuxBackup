#!/bin/bash
# Version 3.0 updated 12/14/13

## GLOBAL CONSTANTS ##

# Users may change the constants in this section

PARTIALTHRESH=1000000 # folders larger than this won't be backed up for partial backups (default 1M)

## DO NOT CHANGE BELOW THIS LINE ##

usage()
{
# Here-doc to stdout
cat 1>&2 << EOF
Usage: backup [OPTION]...

Backs up files and subdirectories located in a user's home folder
OPTIONS:
  -f                backup all files and subdirectories
  -h, --help        display this help menu
  -o                overwrite the directory named with the given date
  -r, --restore     restore an existing backup
EOF
} # Call exit after function call

getEnv() # gets the environment the script is run on
{
	SYS="$(uname -s)"
	if [ "$SYS" = "Linux" ]; then # version is pertinent
		VERSION="$(cat /etc/os-release | grep '^PRETTY_NAME' | sed 's/PRETTY_NAME=//' | sed 's/"//g')"
	fi
	curUser="$(whoami)"
}

newPass()
{
	numTries=0
	while [ $numTries -lt 3 ]; do
		read -s -p "Enter your new password: " firstPass
		echo -en "\n" # print newline
		read -s -p "Confirm your password: " secondPass
		echo -en "\n" # print newline
		if [ "$firstPass" == "$secondPass" ]; then
			echo "$firstPass" > ~/.bpass
			chmod 600 ~/.bpass # prevent peekers
			break
		elif [ $numTries = 2 ]; then
			echo "Error: Too many attempts. Exiting with status (1)." >&2
			exit 1
		else
			numTries=$(($numTries+1))
			echo "Error: Passwords didn't match" >&2
		fi
	done
}

getPassword()
{
	failCount=0
	promptText="$1"
	if [[ -z "$promptText" ]]; then
		echo -en "Internal error: function called with no argument. " >&2
		echo -en "Exiting with status (2).\n" >&2
		exit 2
	fi
	
	SAVEDPASS="$(head -n 1 ~/.bpass)"
	if [ -z "$SAVEDPASS" ]; then
		return # no checking necessary
	fi
	
	while [[ $failCount < 3 ]]; do
		read -s -p "$promptText: " passEntered
		echo ""
		if [[ "$passEntered" = "$SAVEDPASS" ]]; then
			break
		else
			echo "Incorrect password"
			let failCount=$failCount+1
			if [[ $failCount = 3 ]]; then
				echo "Goodbye"
				exit 0
			else
				numTries=$((3-$failCount))
				if [[ $numTries = 1 ]]; then
					echo "You have $numTries more try"
				else
					echo "You have $numTries more tries"
				fi
			fi
		fi
	done
}

# Process arguments with getopts
full=0 # default is partial backup
overwrite=0
restoreBack=0
isTarred=0
folderName="" # empty string

## options ##
getOptions()
{
	while getopts "fhor:tnp" OPTION; do
		case $OPTION in
			h)
				usage # function call
				exit 0
				;;
			f) # set to full backup
				full=1
				;;
			o) # set to overwrite mode
				overwrite=1
				;;
			r)
				restoreBack=$OPTARG
				;;
			t)
				isTarred=1
				;;
			n)
				folderName=$OPTARG
				;;
			p) # new password
				echo -en "You will be prompted for your old password "
				echo -en "before you can select a new password.\n"
				getPassword "Old password" # returns if success
				newPass # also returns upon success
				return 1
				;;
	
			?)
				usage # call function
				exit 1
				;;
		esac
	done
	return 0
}


##########
## main ##
##########

getEnv # gets information regarding the system this is run under

if [ "$1" == "--help" ]; then
	usage
	exit 0
fi

getOptions $* # pass all arguments to this function
firstPrompt=$?

## Password function ##
# Check for current password
if [ ! -f ~/.bpass ]; then
	# NEW PASSWORD
	echo "You need to set your password"
	newPass # function
	# newPass() was success if returns here
elif [ $firstPrompt == 0 ]; then
	getPassword "password"
fi

# Get date and time of backup
echo "Accessing current date" 
rightNow=$(date +"%m_%d_%Y")
echo "The current date is $rightNow"

# Select drive to backup onto

# Handles spaces in filenames
IFS='
'

if [[ "$SYS" = "Linux" ]] && [[ "$VERSION" = "Ubuntu 13"* ]]; then
	allMedia="/media/$curUser"
elif [ "$SYS" = "Linux" ]; then # normal drive array
	allMedia="/media"
elif [ "$SYS" = "Darwin" ]; then # Mac computer
	allMedia="/Volumes"
else
	echo "Environment could not be detected. Exiting with status (2)." >&2
	exit 2
fi

driveArray=(`ls $allMedia`)
arrLen=${#driveArray[@]}
if [[ $arrLen = 0 ]]; then
	echo "Error: no external drive connected. Terminating script" >&2
	exit 1
elif [[ $arrLen = 1 ]]; then
	driveName=${driveArray[0]}
else
	# Loop over array and prompt for user selection of drive

	# Echo available drives
	echo "Multiple drives were found:"
	c=0
	for k in "${driveArray[@]}"; do
		echo "$c: $k"
		let c++
	done
	echo "$c: [Choose folder on local drive]"
	echo "$(($c+1)): [Select to cancel]"

	# Prompt for selection
	while true; do
		read -p "Select your drive by number: " driveNum
		if [[ $driveNum = $(($arrLen + 1)) ]]; then
			echo "Terminating script"
			exit 0
		elif [[ $driveNum = $arrLen ]]; then
			# backup onto folder on local drive
			echo -en "" # do nothing
			exit 3 # DEBUG


		
		elif [[ $driveNum -gt -1 && $driveNum -lt $arrLen ]]; then
			# Valid drive number
			driveName="${driveArray[$driveNum]}"
			break
		else
			echo "Invalid drive selection. Please select again"
		fi
	done
fi

drivePresent=0 # default is false
cd "$allMedia/$driveName"
if [ $? = 0 ]; then # cd was successful
	drivePresent=1
fi

if [ $drivePresent = 0 ]; then # Error with drive / drive not present
	echo "There was an error in locating your drive. Terminating script" >&2
	exit 1
fi

echo "using drive $driveName"

if [ -d backup ]; then
	cd backup
else
	mkdir backup
	if [ $? != 0 ]; then
		echo "Error in creating backup directory. Terminating script." >&2
		exit 1
	fi
	cd backup
fi

modifyName=0
if [[ -z "$folderName" ]]; then
	folderName="$curUser$rightNow"
	modifyName=1
fi

if [[ "$full" = 1 ]]; then # full backup
	echo "Performing a FULL backup"
	while [ true ]; do
		read -p "Are you sure? " sureness
		if [[ "$sureness" = "y" || "$sureness" = "yes" ]]; then
 			if [[ $modifyName = 1 ]]; then
				folderName=$folderName"f"
			fi
			break
		elif [[ "$sureness" = "n" || "$sureness" = "no" ]]; then
			echo "Terminating script"
			exit 0
		else
			echo "Error: Invalid input. Please enter (y/n):"
			continue
		fi
	done
else
	echo "Performing a PARTIAL backup"
fi

if [ -d $folderName ]; then
	if [[ $overwrite = 1 ]]; then # Over write directory
		rm -r $folderName
	else
		echo "Folder $folderName already exists."
		while [ true ]; do
			read -p "Would you like to backup anyway? (y/n) " override 
			if [ "$override" = "y" ]; then
				while [ -d "$folderName" ]; do
					folderName=$folderName"a"
				done
				break
			elif [ "$override" = "n" ]; then
				echo "Goodbye"
				exit 0;
			else
				echo "Error: Invalid input. Enter (y/n):"
				continue
			fi
		done	
	fi
fi

echo "Creating folder $folderName"
mkdir $folderName
if [ $? != 0 ]; then
	echo "Error in creating folder $folderName. Terminating script." >&2
	exit 1
fi

# Copy files onto drive and document
echo "Copying your files to drive"
cd $folderName

echo "User: $curUser" >> info.txt
echo "These files were backed up on $rightNow" >> info.txt

if [ $full = 1 ]; then
	echo "Full backup" >> info.txt
else
	echo "Partial backup" >> info.txt
fi
echo "Directories backed up:" >> info.txt


## Code below is to traverse subdirectories of ~ with loop ##

for k in $(find ~ -maxdepth 1 -not -name ".*" -type d); do
	if [[ $full = 1 ]] || [[ $PARTIALTHRESH -gt $(du -sb $k | awk '{print $1;}') ]]; then
		echo " -$k" >> info.txt
		cp --dereference -r $k .
	fi
done

if [[ $full = 1 ]]; then # Hidden files were previously ignored
	cp --dereference -r ~/.??* .
	echo " -hidden files and directories" >> info.txt
fi

miscFiles=0 # default false
for k in $(find ~ -maxdepth 1 -not -name ".*" -type f); do # Miscellaneous files
	if [[ $full = 1 ]] || [[ $PARTIALTHRESH -gt $(du -sb $k | awk '{print $1;}') ]]; then
		cp --dereference $k . # nonrecursive
		miscFiles=1
	fi
done

if [[ $miscFiles = 1 ]]; then
	echo " -miscellaneous files in /home/$curUser directory" >> info.txt
fi


echo "Backup completed"
exit 0



