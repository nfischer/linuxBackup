#!/bin/bash
# Version 3.0 updated 12/14/13

## GLOBAL CONSTANTS ##

# Users may change the constants in this section

PARTIALTHRESH=1000000 # folders larger than this won't be backed up for partial backups (default 1M)
ACCEPTPASS=1 # change to 0 if you don't want to be prompted for a password

## DO NOT CHANGE BELOW THIS LINE ##

usage()
{
# Here-doc to stdout
cat 1>&2 << "EOF"
Usage: backup [OPTION]...

Backs up files and subdirectories located in a user's home folder
OPTIONS:
  -f                backup all files and subdirectories
  -h, --help        display this help menu
  -o                overwrite the directory named with the given date
  -r, --restore     restore an existing backup
EOF
} # Call exit after function call

getEnv() # gets the environment the script is run on
{
	SYS=$(uname -s)
	if [ $SYS = "Linux" ]; then # version is pertinent
		VERSION=$(cat /etc/os-release | grep '^PRETTY_NAME' | sed 's/PRETTY_NAME=//' | sed 's/"//g')
	fi
	CUR_USER=$(whoami)
}

newPass()
{
	numTries=0
	while [ $numTries -lt 2 ]; do
		read -s -p "Enter your new password: " firstPass
		echo -en "\n" # print newline
		read -s -p "Confirm your password: " secondPass
		echo -en "\n" # print newline
		if [ $firstPass == $secondPass ]; then
			echo "$firstPass" > ~/.bpass
			chmod 600 ~/.bpass # prevent peekers
			break
		elif [ $numTries = 3 ]; then
			echo "Error: Too many attempts. Exiting with status (1)." >&2
			exit 1
		else
			numTries=$(($numTries+1))
			echo "Error: Passwords didn't match" >&2
		fi
	done
}

getPassword()
{
	failCount=0
	
	SAVEDPASS=$(head -n 1 ~/.bpass)
	
	if [[ $ACCEPTPASS = 1 ]]; then # check for password
		while [[ $failCount < 3 ]]; do
			read -s -p "password: " passEntered
			echo ""
			if [[ "$passEntered" = "$SAVEDPASS" ]]; then
				break
			else
				echo "Incorrect password"
				let failCount=$failCount+1
				if [[ $failCount = 3 ]]; then
					echo "Goodbye"
					exit 0
				else
					numTries=$((3-$failCount))
					if [[ $numTries = 1 ]]; then
						echo "You have $numTries more try"
					else
						echo "You have $numTries more tries"
					fi
				fi
			fi
		done
	fi
}

# Process arguments with getopts
full=0 # default is partial backup
overwrite=0
restoreBack=0
isTarred=0
folderName="" # empty string

## options ##
while getopts "fhor:tnp" OPTION; do
	case $OPTION in
		h)
			helpMenu
			exit 0
			;;
		f) # set to full backup
			full=1
			;;
		o) # set to overwrite mode
			overwrite=1
			;;
		r)
			restoreBack=$OPTARG
			;;
		t)
			isTarred=1
			;;
		n)
			folderName=$OPTARG
			;;
		p)
			echo -en "You will be prompted for your old password before "
			echo -en "you can select a new password.\n"
			getPassword # returns if success
			newPass # also returns upon success
			;;

		?)
			helpMenu # call funciton
			exit 1
			;;
	esac
done

#for arg; do
#	if [[ "$arg" = "--help" ]]; then
#		helpMenu
#		exit 0
#	fi
#	
#	c=${arg:0:1}
#	arg=${arg:1}
#
#	if [[ "$c" = "-" ]]; then
#		while test -n "$arg"; do
#			k=${arg:0:1}
#
#			if [ "$k" = "h" ]; then
#				helpMenu
#				exit 0
#			elif [ "$k" = "f" ]; then # set to full backup
#				full=1
#			elif [ "$k" = "o" ]; then # set to overwrite mode
#				overwrite=1
#			elif [ "$k" = "r" ]; then
#				restoreBack=1
#			else
#				echo "backup: invalid option -- '$k'"
#				echo "Try 'backup --help' for more information."
#				exit 1
#			fi
#			arg=${arg:1} # Trim the 1st character
#		done
#
#	else
#		echo "backup: invalid argument"
#		echo "Try 'backup --help' for more information."
#		exit 1
#	fi
#done

##########
## main ##
##########

echo "Backup script"
getEnv # gets information regarding the system this is run under

# Password function
# Check for current password
if [ ! -f ~/.bpass ] || [ "" = $(head -n 1 ~/.bpass) ]; then
	# NEW PASSWORD
	echo "You need to set your password"
	newPass # function
	# newPass() was success if returns here
else
	getPassword
fi


# Get date and time of backup
echo "Accessing current date" 
rightNow=$(date +"%m_%d_%Y")
echo "The current date is $rightNow"


# Select drive to backup onto

# Handles spaces in filenames
IFS='
'

if [[ "$SYS" = "Linux" ]] && [[ "$VERSION" = "Ubuntu 13"* ]]; then
	driveArray=(`ls /media/$CUR_USER/`)
elif [ "$SYS" = "Linux" ]; then # normal drive array
	driveArray=(`ls /media/`)
elif [ "$SYS" = "Darwin" ]; then # Mac computer
	driveArray=(`ls /Volumes`)
else
	echo "Environment could not be detected. Exiting with status (2)." >&2
	exit 2
fi

arrLen=${#driveArray[@]}
if [[ $arrLen = 0 ]]; then
	echo "Error: no external drive connected. Terminating script" >&2
	exit 1
elif [[ $arrLen = 1 ]]; then
	driveName=${driveArray[0]}
else
	# Loop over array and prompt for user selection of drive

	# Echo available drives
	echo "Multiple drives were found:"
	c=0
	for k in "${driveArray[@]}"; do
		echo "$c: $k"
		let c++
	done
	echo "$c: [Choose folder on local drive]"
	echo "$(($c+1)): [Select to cancel]"

	# Prompt for selection
	while true; do
		read -p "Select your drive by number: " driveNum
		if [[ $driveNum = $arrLen ]]; then
			echo "Terminating script"
			exit 0
		elif [[ $driveNum -gt -1 && $driveNum -lt $arrLen ]]; then
			# Valid drive number
			driveName="${driveArray[$driveNum]}"
			break
		else
			echo "Invalid drive selection. Please select again"
		fi
	done
fi

drivePresent=0 # default is false
cd /media/$driveName
if [ $? = 0 ]; then # cd was successful
	drivePresent=1
fi

if [ $drivePresent = 0 ]; then # Error with drive / drive not present
	echo "There was an error in locating your drive. Terminating script" >&2
	exit 1
fi

echo "using drive $driveName"

if [ -d backup ]; then
	cd backup
else
	mkdir backup
	if [ $? != 0 ]; then
		echo "Error in creating backup directory. Terminating script." >&2
		exit 1
	fi
	cd backup
fi

modifyName=0
if [[ -z $folderName ]]; then
	folderName="$CUR_USER$rightNow"
	modifyName=1
fi

if [[ "$full" = 1 ]]; then # full backup
	echo "Performing a FULL backup"
	while [ true ]; do
		read -p "Are you sure? " sureness
		if [[ "$sureness" = "y" || "$sureness" = "yes" ]]; then
 			if [[ $modifyName = 1 ]]; then
				folderName=$folderName"f"
			fi
			break
		elif [[ "$sureness" = "n" || "$sureness" = "no" ]]; then
			echo "Terminating script"
			exit 0
		else
			echo "Error: Invalid input. Please enter (y/n):"
			continue
		fi
	done
else
	echo "Performing a PARTIAL backup"
fi

if [ -d $folderName ]; then
	if [[ $overwrite = 1 ]]; then # Over write directory
		rm -r $folderName
	else
		echo "Folder $folderName already exists."
		while [ true ]; do
			read -p "Would you like to backup anyway? (y/n) " override 
			if [ "$override" = "y" ]; then
				while [ -d "$folderName" ]; do
					folderName=$folderName"a"
				done
				break
			elif [ "$override" = "n" ]; then
				echo "Goodbye"
				exit 0;
			else
				echo "Error: Invalid input. Enter (y/n):"
				continue
			fi
		done	
	fi
fi

echo "Creating folder $folderName"
mkdir $folderName
if [ $? != 0 ]; then
	echo "Error in creating folder $folderName. Terminating script." >&2
	exit 1
fi

# Copy files onto drive and document
echo "Copying your files to drive"
cd $folderName

echo "User: $CUR_USER" >> info.txt
echo "These files were backed up on $rightNow" >> info.txt

if [ $full = 1 ]; then
	echo "Full backup" >> info.txt
else
	echo "Partial backup" >> info.txt
fi
echo "Directories backed up:" >> info.txt


## Code below is to traverse subdirectories of ~ with loop ##

for k in $(find ~ -maxdepth 1 -not -name ".*" -type d); do
	if [[ $full = 1 ]] || [[ $PARTIALTHRESH -gt $(du -sb $k | awk '{print $1;}') ]]; then
		echo " -$k" >> info.txt
		cp --dereference -r $k .
	fi
done

if [[ $full = 1 ]]; then # Hidden files were previously ignored
	cp --dereference -r ~/.??* .
	echo " -hidden files and directories" >> info.txt
fi

miscFiles=0 # default false
for k in $(find ~ -maxdepth 1 -not -name ".*" -type f); do # Miscellaneous files
	if [[ $full = 1 ]] || [[ $PARTIALTHRESH -gt $(du -sb $k | awk '{print $1;}') ]]; then
		cp --dereference $k . # nonrecursive
		miscFiles=1
	fi
done

if [[ $miscFiles = 1 ]]; then
	echo " -miscellaneous files in /home/pi directory" >> info.txt
fi

echo "Backup completed"

exit 0



