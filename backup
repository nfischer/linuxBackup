#!/bin/bash
# Version 2.3.2 updated 10/28/13

## GLOBAL CONSTANTS ##

# Users may change the constants in this section

PARTIALTHRESH=1000000 # folders larger than this won't be backed up for partial backups (default 1M)
DEFAULTPASS="heckuva" # change this to change your password
ACCEPTPASS=1 # change to 0 if you don't want to be prompted for a password

## DO NOT CHANGE BELOW THIS LINE ##

helpMenu()
{
cat << HELPMESSAGE
Usage: backup [OPTION]...

Backs up files and subdirectories located in a user's home folder
OPTIONS:
  -f                backup all files and subdirectories
  -h, --help        display this help menu
  -o                overwrite the directory named with the given date
  -r, --restore     restore an existing backup
HELPMESSAGE
} # Call exit after function call

# Process arguments
full=0 # default is partial backup
overwrite=0
restoreBack=0

for arg; do
	if [[ "$arg" = "--help" ]]; then
		helpMenu
		exit 0
	fi
	
	c=${arg:0:1}
	arg=${arg:1}

	if [[ "$c" = "-" ]]; then
		while test -n "$arg"; do
			k=${arg:0:1}

			if [ "$k" = "h" ]; then
				helpMenu
				exit 0
			elif [ "$k" = "f" ]; then # set to full backup
				full=1
			elif [ "$k" = "o" ]; then # set to overwrite mode
				overwrite=1
			elif [ "$k" = "r" ]; then
				restoreBack=1
			else
				echo "backup: invalid option -- '$k'"
				echo "Try 'backup --help' for more information."
				exit 1
			fi
			arg=${arg:1} # Trim the 1st character
		done

	else
		echo "backup: invalid argument"
		echo "Try 'backup --help' for more information."
		exit 1
	fi
done

echo "Backup script"

## Help Function
#if [[ $helpMenu = 1 ]]; then
#	echo "Help Menu"
#	echo "Under construction"
#	echo "Usage: backup [OPTION]..."
#	echo -e "Backs up files and subdirectories located in /home/pi\n"
#	echo "  -f			    backup all files and subdirectories"
#	echo "  -h, --help		    display this help menu"
#	echo -e "  -o			    overwrite the directory named with the given date\n"
#	exit 0
#fi

# Password
if [[ $ACCEPTPASS = 1 ]]; then # check for password
	read -s -p "password: " passEntered
	echo ""
	if [ "$passEntered" != "$DEFAULTPASS" ]; then
		echo "Incorrect password"
		echo "Goodbye"
		exit 0
	fi
fi

# Get date and time of backup
echo "Accessing current date" 
rightNow=$(date +"%m_%d_%Y")
echo "The current date is $rightNow"

# Select drive to backup onto

# Handles spaces in filenames
IFS='
'

driveArray=(`ls /media`)

arrLen=${#driveArray[@]}
if [[ $arrLen = 0 ]]; then
	echo "Error: no external drive connected. Terminating script"
	exit 1
elif [[ $arrLen = 1 ]]; then
	driveName=${driveArray[0]}
else
	# Loop over array and prompt for user selection of drive

	# Echo available drives
	echo "Multiple drives were found:"
	c=0
	for k in "${driveArray[@]}"; do
		echo "$c: $k"
		let c++
	done
	echo "$c: [Select to cancel]"

	# Prompt for selection
	while true; do
		read -p "Select your drive by number: " driveNum
		if [[ $driveNum = $arrLen ]]; then
			echo "Terminating script"
			exit 0
		elif [[ $driveNum -gt -1 && $driveNum -lt $arrLen ]]; then
			# Valid drive number
			driveName="${driveArray[$driveNum]}"
			break
		else
			echo "Invalid drive selection. Please select again"
		fi
	done
fi

drivePresent=0 # default is false
cd /media/$driveName
if [ $? = 0 ]; then # cd was successful
	drivePresent=1
fi

if [ $drivePresent = 0 ]; then # Error with drive / drive not present
	echo "There was an error in locating your drive. Terminating script"
	exit 1
fi

echo "using drive $driveName"

if [ -d backup ]; then
	cd backup
else
	mkdir backup
	if [ $? != 0 ]; then
		echo "Error in creating backup directory. Terminating script."
		exit 1
	fi
	cd backup
fi

foldername="$(whoami)$rightNow"

if [ "$full" = 1 ]; then # full backup
	echo "Performing a FULL backup"
	while [ true ]; do
		read -p "Are you sure? " sureness
		if [[ "$sureness" = "y" || "$sureness" = "yes" ]]; then
			foldername=$foldername"f"
			break
		elif [[ "$sureness" = "n" || "$sureness" = "no" ]]; then
			echo "Terminating script"
			exit 0
		else
			echo "Error: Invalid input. Please enter (y/n):"
			continue
		fi
	done
else
	echo "Performing a PARTIAL backup"
fi

if [ -d $foldername ]; then
	if [[ $overwrite = 1 ]]; then # Over write directory
		rm -r $foldername
	else
		echo "Folder $foldername already exists."
		while [ true ]; do
			read -p "Would you like to backup anyway? (y/n) " override 
			if [ "$override" = "y" ]; then
				while [ -d "$foldername" ]; do
					foldername=$foldername"a"
				done
				break
			elif [ "$override" = "n" ]; then
				echo "Goodbye"
				exit 0;
			else
				echo "Error: Invalid input. Enter (y/n):"
				continue
			fi
		done	
	fi
fi

echo "Creating folder $foldername"
mkdir $foldername
if [ $? != 0 ]; then
	echo "Error in creating folder $foldername. Terminating script."
	exit 1
fi

# Copy files onto drive and document
echo "Copying your files to drive"
cd $foldername

echo "These files were backed up on $rightNow" >> info.txt

if [ $full = 1 ]; then
	echo "Full backup" >> info.txt
else
	echo "Partial backup" >> info.txt
fi
echo "Directories backed up:" >> info.txt


## Code below is to traverse subdirectories of ~ with loop ##

for k in $(find ~ -maxdepth 1 -not -name ".*" -type d); do
	if [[ $full = 1 ]] || [[ $PARTIALTHRESH -gt $(du -sb $k | awk '{print $1;}') ]]; then
		echo " -$k" >> info.txt
		cp --dereference -r $k .
	fi
done

if [[ $full = 1 ]]; then # Hidden files were previously ignored
	cp --dereference -r ~/.??* .
	echo " -hidden files and directories" >> info.txt
fi

miscFiles=0 # default false
for k in $(find ~ -maxdepth 1 -not -name ".*" -type f); do # Miscellaneous files
	if [[ $full = 1 ]] || [[ $PARTIALTHRESH -gt $(du -sb $k | awk '{print $1;}') ]]; then
		cp --dereference $k . # nonrecursive
		miscFiles=1
	fi
done

if [[ $miscFiles = 1 ]]; then
	echo " -miscellaneous files in /home/pi directory" >> info.txt
fi

echo "Backup completed"

exit 0



